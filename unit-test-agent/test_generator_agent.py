"""
test_generator_agent.py

ü§ñ GERADOR AUTOM√ÅTICO DE TESTES PYTEST COM AZURE OPENAI
=========================================================

Este agente utiliza LangChain + Azure OpenAI para gerar automaticamente
arquivos de teste pytest a partir de m√≥dulos Python.

FUNCIONALIDADES:
- ‚úÖ Extrai fun√ß√µes automaticamente do c√≥digo fonte
- ‚úÖ Gera testes de sucesso e falha
- ‚úÖ Usa @pytest.mark.parametrize para organizar casos
- ‚úÖ Compat√≠vel com LangChain ‚â•0.2 e OpenAI ‚â•1.0.0
- ‚úÖ Sistema de debugging e valida√ß√£o

DEPEND√äNCIAS:
pip install langchain langchain-openai openai python-dotenv pytest

"""

import ast
import os
import sys
from typing import List, Dict, Optional
from dotenv import load_dotenv

# -------------------------------
# Imports LangChain atualizados
# -------------------------------
try:
    from langchain_core.prompts import PromptTemplate
    from langchain_openai import AzureChatOpenAI
    print("‚úÖ Depend√™ncias LangChain carregadas com sucesso")
except ImportError as e:
    print(f"‚ùå Erro ao importar LangChain: {e}")
    print("   Execute: pip install langchain langchain-openai")
    sys.exit(1)


# -------------------------------
# Utilit√°rios de an√°lise de c√≥digo
# -------------------------------
def extract_functions_info(code: str) -> List[Dict]:
    """
    Extrai informa√ß√µes detalhadas de todas as fun√ß√µes top-level do c√≥digo.
    
    Args:
        code (str): C√≥digo fonte Python
        
    Returns:
        List[Dict]: Lista com informa√ß√µes das fun√ß√µes (name, args, doc, source)
        
    Raises:
        SyntaxError: Se o c√≥digo n√£o for Python v√°lido
    """
    try:
        tree = ast.parse(code)
    except SyntaxError as e:
        raise SyntaxError(f"C√≥digo Python inv√°lido: {e}")
    
    functions = []
    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            name = node.name
            args = [arg.arg for arg in node.args.args]
            doc = ast.get_docstring(node) or ""
            
            # Tentar extrair c√≥digo fonte
            try:
                source = ast.get_source_segment(code, node) or ""
            except (AttributeError, Exception):
                # Fallback para vers√µes antigas do Python
                lines = code.split('\n')
                start_line = node.lineno - 1
                end_line = node.end_lineno if hasattr(node, 'end_lineno') else start_line + 10
                source = '\n'.join(lines[start_line:end_line])
            
            functions.append({
                "name": name,
                "args": args, 
                "doc": doc,
                "source": source.strip(),
                "line_number": node.lineno
            })
    
    return functions


def validate_python_syntax(code: str) -> bool:
    """Valida se o c√≥digo Python tem sintaxe correta."""
    try:
        ast.parse(code)
        return True
    except SyntaxError:
        return False


# -------------------------------
# Prompt otimizado para gera√ß√£o de testes
# -------------------------------
PROMPT_TEMPLATE = """Voc√™ √© um especialista em testes Python que cria arquivos pytest profissionais e abrangentes.

üéØ OBJETIVO: Criar um arquivo de teste pytest completo e bem estruturado.

üìã REGRAS OBRIGAT√ìRIAS:
1. IN√çCIO: O arquivo deve come√ßar exatamente com 'import pytest'
2. IMPORTS: Importe as fun√ß√µes usando: from {module_name} import fun√ß√£o1, fun√ß√£o2, ...
3. TESTES: Para cada fun√ß√£o, crie:
   - Testes de casos v√°lidos (sucesso)
   - Testes de casos inv√°lidos (exce√ß√µes/erros)
   - Testes de casos extremos (edge cases)
4. ORGANIZA√á√ÉO: Use @pytest.mark.parametrize sempre que poss√≠vel
5. NOMES: Use nomes descritivos: test_[fun√ß√£o]_[cen√°rio]
6. COBERTURA: Teste diferentes tipos de entrada e sa√≠da

üîß ESTRUTURA DE CADA TESTE:
- test_[fun√ß√£o]_success_cases: Casos que devem funcionar
- test_[fun√ß√£o]_invalid_inputs: Entradas que devem gerar erro
- test_[fun√ß√£o]_edge_cases: Casos extremos

‚ö° INFORMA√á√ïES DO M√ìDULO:
Nome do m√≥dulo: {module_name}
N√∫mero de fun√ß√µes: {function_count}

üìä DETALHES DAS FUN√á√ïES:
{functions_info}

üß™ C√ìDIGO COMPLETO DO M√ìDULO:
```python
{code}
```

üíª RESPOSTA: Gere APENAS o conte√∫do do arquivo test_{module_name}.py (sem explica√ß√µes):"""


# -------------------------------
# Fun√ß√µes principais de gera√ß√£o
# -------------------------------
def generate_pytest_for_code(code: str, module_name: str, llm) -> str:
    """
    Gera o conte√∫do do arquivo de testes pytest usando o modelo LLM.
    
    Args:
        code (str): C√≥digo fonte do m√≥dulo
        module_name (str): Nome do m√≥dulo (sem extens√£o)
        llm: Inst√¢ncia do modelo LangChain
        
    Returns:
        str: Conte√∫do do arquivo de teste gerado
        
    Raises:
        ValueError: Se nenhuma fun√ß√£o for encontrada
        Exception: Se houver erro na gera√ß√£o
    """
    print(f"üîç Analisando c√≥digo do m√≥dulo '{module_name}'...")
    
    # Validar sintaxe do c√≥digo
    if not validate_python_syntax(code):
        raise ValueError("C√≥digo fonte cont√©m erros de sintaxe")
    
    # Extrair informa√ß√µes das fun√ß√µes
    functions = extract_functions_info(code)
    if not functions:
        raise ValueError("Nenhuma fun√ß√£o top-level encontrada no c√≥digo fornecido.")
    
    print(f"üìä Encontradas {len(functions)} fun√ß√£o(s): {[f['name'] for f in functions]}")
    
    # Formatar informa√ß√µes das fun√ß√µes para o prompt
    function_details = []
    for func in functions:
        detail = f"""
FUN√á√ÉO: {func['name']}
‚îú‚îÄ‚îÄ Assinatura: {func['name']}({', '.join(func['args'])})
‚îú‚îÄ‚îÄ Linha: {func['line_number']}
‚îú‚îÄ‚îÄ Docstring: {func['doc'] or 'N√£o documentada'}
‚îî‚îÄ‚îÄ C√≥digo:
{func['source']}
"""
        function_details.append(detail.strip())
    
    functions_info = "\n" + "="*50 + "\n".join(function_details)
    
    # Criar prompt
    prompt = PromptTemplate(
        input_variables=["module_name", "function_count", "functions_info", "code"],
        template=PROMPT_TEMPLATE,
    )
    
    print("ü§ñ Gerando testes com Azure OpenAI...")
    
    # Usar a sintaxe moderna do LangChain
    chain = prompt | llm
    
    try:
        result = chain.invoke({
            "module_name": module_name,
            "function_count": len(functions),
            "functions_info": functions_info,
            "code": code
        })
        
        # Extrair conte√∫do da resposta
        if hasattr(result, 'content'):
            content = result.content
        else:
            content = str(result)
            
        print("‚úÖ Testes gerados com sucesso!")
        return content
        
    except Exception as e:
        print(f"‚ùå Erro na gera√ß√£o: {e}")
        raise Exception(f"Falha ao gerar testes: {e}")


def generate_pytest_from_file(file_path: str, llm, output_path: Optional[str] = None) -> str:
    """
    L√™ um arquivo Python e gera arquivo de testes correspondente.
    
    Args:
        file_path (str): Caminho para o arquivo Python
        llm: Inst√¢ncia do modelo LangChain
        output_path (str, optional): Caminho de sa√≠da personalizado
        
    Returns:
        str: Conte√∫do do arquivo de teste gerado
        
    Raises:
        FileNotFoundError: Se o arquivo n√£o existir
        Exception: Se houver erro na gera√ß√£o
    """
    print(f"üìÇ Processando arquivo: {file_path}")
    
    # Verificar se arquivo existe
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"Arquivo n√£o encontrado: {file_path}")
    
    # Ler c√≥digo fonte
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            code = f.read()
        print(f"‚úÖ Arquivo lido: {len(code)} caracteres")
    except Exception as e:
        raise Exception(f"Erro ao ler arquivo: {e}")
    
    # Extrair nome do m√≥dulo
    module_name = os.path.splitext(os.path.basename(file_path))[0]
    
    # Gerar conte√∫do dos testes
    test_content = generate_pytest_for_code(code, module_name, llm)
    
    # Definir caminho de sa√≠da
    if output_path is None:
        output_path = f"test_{module_name}.py"
    
    # Salvar arquivo de teste
    try:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(test_content)
        print(f"üíæ Arquivo de teste salvo: {output_path}")
    except Exception as e:
        print(f"‚ö†Ô∏è  Erro ao salvar arquivo: {e}")
        print("üîç Conte√∫do gerado:")
        print("-" * 50)
        print(test_content)
        print("-" * 50)
        raise
    
    return test_content


def test_azure_connection() -> bool:
    """
    Testa a conex√£o com Azure OpenAI com informa√ß√µes detalhadas de debug.
    
    Returns:
        bool: True se conex√£o bem-sucedida, False caso contr√°rio
    """
    load_dotenv()
    
    azure_endpoint = os.getenv("AZURE_ENDPOINT")
    api_key = os.getenv("OPENAI_API_KEY")
    deployment_name = os.getenv("AZURE_DEPLOYMENT_NAME")
    api_version = os.getenv("OPENAI_API_VERSION", "2023-05-15")
    temperature = float(os.getenv("TEMPERATURE", "0.1"))
    
    print("üîç Debug - Configura√ß√µes carregadas:")
    print(f"   AZURE_ENDPOINT: {azure_endpoint}")
    print(f"   AZURE_DEPLOYMENT_NAME: {deployment_name}")
    print(f"   API_KEY: {'*' * 20 + api_key[-10:] if api_key else 'N√£o encontrada'}")
    print(f"   API_VERSION: {api_version}")
    print(f"   TEMPERATURE: {temperature}")
    
    # Valida√ß√µes b√°sicas
    if not all([azure_endpoint, api_key, deployment_name]):
        print("‚ùå Erro: Vari√°veis obrigat√≥rias n√£o encontradas no .env")
        print("   Verifique se AZURE_ENDPOINT, OPENAI_API_KEY e AZURE_DEPLOYMENT_NAME est√£o definidas")
        return False
    
    if not azure_endpoint.startswith("https://"):
        print("‚ùå Erro: AZURE_ENDPOINT deve come√ßar com https://")
        return False
    
    if not azure_endpoint.endswith("/"):
        print("‚ö†Ô∏è  Aviso: AZURE_ENDPOINT deve terminar com '/' - corrigindo automaticamente")
        azure_endpoint = azure_endpoint + "/"
    
    try:
        print("\nüöÄ Testando conex√£o com Azure OpenAI...")
        llm = AzureChatOpenAI(
            azure_endpoint=azure_endpoint,
            azure_deployment=deployment_name,
            api_key=api_key,
            api_version=api_version,
            temperature=temperature,
            max_tokens=50
        )
        
        # Teste simples
        print("üì° Enviando mensagem de teste...")
        response = llm.invoke("Responda apenas: Conex√£o OK!")
        
        if hasattr(response, 'content'):
            response_text = response.content
        else:
            response_text = str(response)
            
        print(f"‚úÖ Sucesso! Resposta do modelo: '{response_text.strip()}'")
        return True
        
    except Exception as e:
        print(f"‚ùå Erro na conex√£o: {type(e).__name__}: {e}")
        
        # Sugest√µes espec√≠ficas baseadas no tipo de erro
        error_str = str(e).lower()
        if "404" in error_str:
            print("üí° Sugest√£o: Verifique se o deployment foi criado e o nome est√° correto")
        elif "401" in error_str or "unauthorized" in error_str:
            print("üí° Sugest√£o: Verifique se a API key est√° correta e v√°lida")
        elif "timeout" in error_str:
            print("üí° Sugest√£o: Problema de conectividade - tente novamente")
        else:
            print("üí° Sugest√£o: Execute 'python diagnose_azure_openai.py' para mais detalhes")
        
        return False


# -------------------------------
# Execu√ß√£o principal
# -------------------------------
def main():
    """Fun√ß√£o principal que coordena a execu√ß√£o do gerador de testes."""
    print("ü§ñ GERADOR AUTOM√ÅTICO DE TESTES PYTEST")
    print("=" * 45)
    print("üìÖ Vers√£o: 1.0 | Data: 2025-09-16")
    print("üîó Powered by: LangChain + Azure OpenAI")
    print()
    
    # Primeiro testa a conex√£o
    print("üîß ETAPA 1: Verifica√ß√£o da configura√ß√£o")
    print("-" * 30)
    if not test_azure_connection():
        print("\nüõë Parando execu√ß√£o devido ao erro de conex√£o.")
        print("\nüìã PR√ìXIMOS PASSOS:")
        print("1. Verifique o arquivo .env")
        print("2. Execute: python diagnose_azure_openai.py")
        print("3. Confirme se o deployment foi criado no portal Azure")
        sys.exit(1)
    
    print("\nüß† ETAPA 2: Inicializa√ß√£o do modelo")
    print("-" * 30)
    
    # Carregar configura√ß√µes
    load_dotenv()
    azure_endpoint = os.getenv("AZURE_ENDPOINT")
    api_key = os.getenv("OPENAI_API_KEY")
    deployment_name = os.getenv("AZURE_DEPLOYMENT_NAME")
    api_version = os.getenv("OPENAI_API_VERSION", "2023-05-15")
    temperature = float(os.getenv("TEMPERATURE", "0.1"))
    max_tokens = int(os.getenv("MAX_TOKENS", "2000"))
    
    # Criar inst√¢ncia do LLM
    try:
        llm = AzureChatOpenAI(
            azure_endpoint=azure_endpoint,
            azure_deployment=deployment_name,
            api_key=api_key,
            api_version=api_version,
            temperature=temperature,
            max_tokens=max_tokens
        )
        print(f"‚úÖ Modelo configurado: {deployment_name}")
        print(f"   Temperature: {temperature} | Max tokens: {max_tokens}")
    except Exception as e:
        print(f"‚ùå Erro ao configurar modelo: {e}")
        sys.exit(1)
    
    print("\nüìÇ ETAPA 3: Processamento do arquivo")
    print("-" * 30)
    
    # Determinar arquivo de entrada
    if len(sys.argv) > 1:
        input_file = sys.argv[1]
    else:
        input_file = "sample_module.py"
    
    print(f"üìÑ Arquivo de entrada: {input_file}")
    
    # Verificar se arquivo existe
    if not os.path.exists(input_file):
        print(f"‚ùå Arquivo n√£o encontrado: {input_file}")
        print("\nüìã ARQUIVOS PYTHON DISPON√çVEIS:")
        python_files = [f for f in os.listdir('.') if f.endswith('.py') and not f.startswith('test_')]
        for file in python_files:
            print(f"   ‚Ä¢ {file}")
        sys.exit(1)
    
    # Gerar arquivo de testes
    try:
        print(f"\nüöÄ Gerando testes para {input_file}...")
        test_content = generate_pytest_from_file(input_file, llm)
        
        # Estat√≠sticas
        lines = len(test_content.split('\n'))
        test_functions = test_content.count('def test_')
        
        print(f"\nüìä ESTAT√çSTICAS DO ARQUIVO GERADO:")
        print(f"   üìè Linhas de c√≥digo: {lines}")
        print(f"   üß™ Fun√ß√µes de teste: {test_functions}")
        print(f"   üìÅ Arquivo salvo: test_{os.path.splitext(os.path.basename(input_file))[0]}.py")
        
        print(f"\n‚úÖ PROCESSO CONCLU√çDO COM SUCESSO!")
        print(f"\nüß™ Para executar os testes:")
        print(f"   pytest test_{os.path.splitext(os.path.basename(input_file))[0]}.py -v")
        
    except FileNotFoundError as e:
        print(f"‚ùå Arquivo n√£o encontrado: {e}")
    except ValueError as e:
        print(f"‚ùå Erro de valida√ß√£o: {e}")
    except Exception as e:
        print(f"‚ùå Erro durante gera√ß√£o: {e}")
        print("\nüîç Para diagn√≥stico detalhado, execute:")
        print("   python diagnose_azure_openai.py")
        sys.exit(1)


if __name__ == "__main__":
    main()
